#	클래스

- 클래스는 함수임
- 새로운 객체 생성 방식



##	클래스 정의

- `class ` 키워드 사용

<code>

class Car {} // 클래스 선언문

const a = class {}; // 익명 클래스 표현식

const b = class Person {}; // 기명 클래스 표현식

</code>

- 클래스를 표현식으로 정의할 수 있다는 것 --> 일급 객체
- 클래스 몸체에는 0개 이상의 메서드 정의 가능
- 메서드 종류
  - `constructor`, 프로토타입 메서드, 정적 메서드



##	클래스 호이스팅

- 런타임 이전에 평가되어 함수 객체 생성 --> 이때 생성된 생성자 함수 객체 === `constructor`
- 클래스 선언문 이전에 일시적 사각지대 발생
- 클래스는 클래스 정의 이전에 참조 불가능



##	인스턴스 생성

- 인스턴스 생성이 유일한 목표 --> `new` 연산자와 함께 호출



##	메서드

- 클래스 몸체에는 0개 이상의 메서드만 선언할 수 있음
- `constructor`
  - 이름을 변경할 수 없음
  - 메서드로 해석되지 않고 클래스가 평가돼 생성한 함수 객체 코드의 일부가 됨
  - 1개만 존재 가능
  - 생략 가능
  - 인스턴스를 초기화하려면 반드시 작성해야 함
- 프로토타입 메서드
  - 클래스 몸체에 정의한 메서드는 기본이 프로토타입 메서드임
  - 클래스가 생성한 인스턴스는 프로토타입 체인 안에 속함
  - 인스턴스로 호출
  - 인스턴스의 프로퍼티 참조 가능
- 정적 메서드
  - `static` 키워드를 붙이면 정적 메서드가 됨
  - 프로토타입 체인이 프로토타입 메서드와 다름
  - 클래스로 호출
  - 인스턴스의 프로퍼티 참조 불가능



##	인스턴스 생성 과정

1. 인스턴스 생성, this 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환



##	프로퍼티

- 인스턴스 프로퍼티
  - `constructor` 내부에서 정의해야 함
  - `constructor` 내부에서 this에 추가한 프로퍼티는 인스턴스의 프로퍼티가 됨
- 접근자 프로퍼티
  - 인스턴스에서 사용
  - 프로퍼티처럼 참조 O --> 내부적으로 호출됨

- 클래스 필드 정의
  - this 없이 프로퍼티를 클래스 몸체에 선언
  - 클래스 필드를 참조하는 경우 반드시 this로 참조해야 함
  - 초기값이 없으면 `undefined` 할당
  - 모든 클래스 필드는 인스턴스 프로퍼티, 함수 할당 --> 인스턴스 메서드
  - private 사용하려면 필드 이름 앞에 # 추가
  - 정적 필드 사용하려면 `static` 키워드 선언



##	상속에 의한 클래스 확장

- 기존 클래스를 상속받아 새로운 클래스를 확장함
- 서브클래스의 `constructor`에 반드시 `super`를 호출해야 함 --> 서브클래스는 수퍼클래스에게 인스턴스 생성을 위임하기 때문